# Compression dictionary transport

## Настройки

### `dictionaryCompression.dictionaryPath`
**Тип:** `string[]`
**По умолчанию:** `[]`
**Описание:** Массив путей до предыдущих версий ассетов или готовых словарей для сжатия бандла приложения.

- Поддерживает как абсолютные, так и относительные пути (относительно корня проекта)
- Может содержать как файлы (готовые словари), так и директории (предыдущие версии приложения)
- Словари будут скопированы в директорию сборки
- Директории используются для создания DCB-файлов из предыдущих версий

### `dictionaryCompression.enablePreviousVersionHeaders`
**Тип:** `boolean`
**По умолчанию:** `false`
**Описание:** Включает автоматическую простановку заголовка `brotli_auto_dictionary on;` в конфигурации nginx для использования ресурсов приложения как словарей.

## Пример конфигурации

```ts
import { PackageSettings } from 'arui-scripts';

const settings: PackageSettings = {
    dictionaryCompression: {
        dictionaryPath: [
            './build-v1.0', // Предыдущая версия (директория)
            './custom.dict'  // Готовый словарь (файл)
        ],
        enablePreviousVersionHeaders: true
    }
};

export default settings;
```

## Общее описание механизма

Механизм [compression dictionary transport](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Compression_dictionary_transport)
позволяет использовать кастомные словари для сжатия ресурсов приложения.

На данный момент arui-scripts поддерживает два механизма работы со словарями:
1. Использование вашего собственного словаря для сжатия ресурсов приложения
2. Использование одной версии вашего приложения для сжатия ресурсов другой версии.

Оба механизма работают только для prod сборки приложения при использовании базового docker образа, поставляемого с arui-scripts.

### Использование вашего словаря

По умолчанию brotli использует встроенный в него словарь для более эффективного сжатия. Встроенный в brotli словарь подготовлен
на основании данных из всего интернета. Если сделать словарь персонально под ваши ресурсы - можно получить более эффективное сжатие, даже
учитывая дополнительные затраты на загрузку словаря на клиент.

#### Создание персонального словаря
Для создания персонального словаря вы можете использовать утилиту [brotli-dict](https://www.npmjs.com/package/brotli-dict).

```shell
npx brotli-dict generate file1.js file2.js file3.css -o dictionary.dict -s 200000
```

Здесь:
- `file1.js`, `file2.js`, `file3.css` - произвольные текстовые файлы которые вы хотите использовать для создания словаря
- `dictionary.dict` - имя файла для создаваемого словаря
- `-s 200000` - ограничивает максимальную длину словаря в 200000. Имейте в виду, что словарь после создания так же можно сжать, поэтому по сети будет передаваться меньше данных.

Рекомендуется создать 1 словарь на всю систему, живущую на одном домене. Вы можете взять ресурсы с самых посещаемых страниц и использовать их как исходники для словаря.
Обновлять их при изменении приложений не обязательно - словари скорее всего не будут содержать сильно специфичного для конкретной версии контента.

#### Выбор идентификатора для словаря

Для корректной работы со словарем у него должен быть идентификатор. Он будет:
- использоваться как имя файла для словаря
- использоваться как суффикс имени сжатых словарем ассетов
- использоваться в заголовке `Use-As-Dictionary`.

В дальнейших примерах я буду использовать идентификатор `dict-id`.

#### Загрузка словаря на клиент
Для того чтобы браузер начал использовать словари их нужно как то загрузить на клиент.
Это можно сделать 3 способами:

- Указав заголовок `Link '</assets/dict-id.dict>; rel="compression-dictionary"';` в ответе на запрос за любым документом
- Добавив тег `<link rel="compression-dictionary" href="./assets/dict-id.dict" />` в html вашего приложения
- Сделав `fetch` адреса словаря из вашего кода (`fetch('./assets/dict-id.dict')`).

В независимости от метода, в ответ браузер **должен** получить помимо контента словаря так же заголовок `Use-As-Dictionary`, например:
```
Use-As-Dictionary: 'match="/assets/*", id="dict-id"'
```

Вы можете добиться этого добавив такие строки в nginx.conf:

```
    location /assets/dict-id.dict {
        expires max;
        add_header Use-As-Dictionary 'match="/assets/*", id="dict-id"';
        root /src/.build;
    }
```

Про то, как корректно настраивать заголовок `Use-As-Dictionary` можно прочитать в [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Use-As-Dictionary).

### Использование предыдущих версий приложения

Если ваше приложение часто обновляется, а пользователи все время возвращаются - можно использовать механизм сжатия с помощью предыдущих версий.
Он может давать очень высокий коэффицент сжатия если у пользователя есть предыдущая версия приложения в кеше.

#### Настройка

```ts
const settings: PackageSettings = {
    dictionaryCompression: {
        dictionaryPath: [
            './previous-builds/v1.0/assets',
            './previous-builds/v1.1/assets'
        ],
        enablePreviousVersionHeaders: true
    }
};
```

При такой конфигурации:
1. **arui-scripts** найдёт все `.js` и `.css` файлы в указанных директориях
2. Создаст DCB-файлы (Dictionary Compressed Brotli) для каждого файла текущей сборки, используя соответствующие файлы из предыдущих версий как словари
3. Nginx будет настроен с `brotli_auto_dictionary on;` для автоматического использования этих словарей

Соответствие файлов определяется по их имени. Считаем что файлы в сборке используют формат вида `{stable-name}.{hash}.{ext}`. Соответствующими считаются файлы с одинаковым
`{stable-name}` и `{ext}`.
DCB файлы будут иметь название `{stable-name}.{hash}.{ext}.{dict hash}.dcb`.
